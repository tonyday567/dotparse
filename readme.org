#+TITLE: dotparse

[[https://hackage.haskell.org/package/dotparse][file:https://img.shields.io/hackage/v/dotparse.svg]] [[https://github.com/tonyday567/chart-svg/actions?query=workflow%3Ahaskell-ci][file:https://github.com/tonyday567/dotparse/workflows/haskell-ci/badge.svg]]

* imports

#+begin_src haskell-ng :results output
:reload
:set -XOverloadedLabels
:set -XOverloadedStrings
:set -Wno-type-defaults
:set -Wno-x-partial
:set -XImportQualifiedPost
import Chart
import Optics.Core
import FlatParse.Basic qualified as FP
import qualified Data.ByteString as BS
import qualified Data.Text as Text
import qualified Data.ByteString.Char8 as Char8
import Algebra.Graph qualified as G
import Data.Monoid
import GHC.Exts
import DotParse
import DotParse.Examples
import DotParse.Examples.AST
import DotParse.Examples.NumHask
import DotParse.Examples.Base
import Data.Proxy
print "ok"
#+end_src

* Introduction

Parsing and printing for the dot language of graphviz.

- A close rendition of the [[http://www.graphviz.org/doc/info/lang.html][dot language specification]]
- Supports inexact printing . parsing round trip; forgetting comments, separator choice and whitespace.
- Treats attribute keys and values as ByteStrings. No Type safety of Attributes is attempted.
- Uses command-line graphviz programs `dot` and `neato` to augment dot graph specifications
- Supports conversion from and to [[https://hackage.haskell.org/package/algebraic-graphs][algebraic-graphs]].
- Support rendering dot graphs using [[https://hackage.haskell.org/package/chart-svg][chart-svg]].
- Uses [[https://hackage.haskell.org/package/flatparse][flatparse]] for speedy parsing.

** Reference

Graphviz documentation:

[[https://www.graphviz.org/][Graphviz Main Page]]

[[http://magjac.com/graphviz-visual-editor/][Graphviz Visual Editor]]

[[http://www.graphviz.org/doc/info/attrs.html][Attributes | Graphviz]]

[[http://www.graphviz.org/pdf/dot.1.pdf][Dot Grammar]]

Graphviz practical examples:

https://renenyffenegger.ch/notes/tools/Graphviz/examples/index

https://renenyffenegger.ch/notes/tools/Graphviz/attributes/label/HTML-like/index

** Similar projects

The [[https://hackage.haskell.org/package/graphviz][graphviz]] library aims for comprehensive typing of graphviz attributes and syntax. As a result, it is quite large and somewhat incomplete. In contrast, dotparse parsing is simpler, more robust and faster. It is also somewhat tied to fgl and I wanted to try a different graph library.

[[https://hackage.haskell.org/package/dotgen][dotgen]] is a dot graph printer but not a parser. It supports a monadic style of printing. Specifically, it supports generation of unique names if that is an important feature of the problem domain.

** development wish list

Target [[https://hackage.haskell.org/package/calligraphy][calligraphy]] for enhanced source code visualization.

Broaden support to include fgl and containers.

Support parsing of library graphs from cabal.

Explore [[https://kowainik.github.io/posts/2019-01-14-tomland#tagged-partial-bidirectional-isomorphism][tagged partial birectional isomorphism]] style.

Steal design ideas from [[https://hackage.haskell.org/package/jordan][jordan]].

Case-insensitive parsing blocked on [[https://github.com/AndrasKovacs/flatparse/issues/10][AndrasKovacs/flatparse#10 Case-insensitive keyword matching]].

Exact printing of comments and whitespace.

* process pipelines

** algebraic-graphs
Starting with a Graph from algebraic-graphs:

#+begin_src haskell
import qualified Algebra.Graph as G
:{
exAGraph :: G.Graph Int
exAGraph =
  G.edges $
    [(v, (v + 1) `mod` 6) | v <- [0 .. 5]]
      <> [(v, v + k) | v <- [0 .. 5], k <- [6, 12]]
      <> [(2, 18), (2, 19), (15, 18), (15, 19), (18, 3), (19, 3)]
:}
#+end_src

#+RESULTS:
: ghci| ghci| ghci| ghci| ghci| ghci| ghci|

#+begin_src haskell :results output :exports both
exAGraph
#+end_src

#+RESULTS:
: Overlay (Connect (Vertex 0) (Vertex 1)) (Overlay (Connect (Vertex 1) (Vertex 2)) (Overlay (Connect (Vertex 2) (Vertex 3)) (Overlay (Connect (Vertex 3) (Vertex 4)) (Overlay (Connect (Vertex 4) (Vertex 5)) (Overlay (Connect (Vertex 5) (Vertex 0)) (Overlay (Connect (Vertex 0) (Vertex 6)) (Overlay (Connect (Vertex 0) (Vertex 12)) (Overlay (Connect (Vertex 1) (Vertex 7)) (Overlay (Connect (Vertex 1) (Vertex 13)) (Overlay (Connect (Vertex 2) (Vertex 8)) (Overlay (Connect (Vertex 2) (Vertex 14)) (Overlay (Connect (Vertex 3) (Vertex 9)) (Overlay (Connect (Vertex 3) (Vertex 15)) (Overlay (Connect (Vertex 4) (Vertex 10)) (Overlay (Connect (Vertex 4) (Vertex 16)) (Overlay (Connect (Vertex 5) (Vertex 11)) (Overlay (Connect (Vertex 5) (Vertex 17)) (Overlay (Connect (Vertex 2) (Vertex 18)) (Overlay (Connect (Vertex 2) (Vertex 19)) (Overlay (Connect (Vertex 15) (Vertex 18)) (Overlay (Connect (Vertex 15) (Vertex 19)) (Overlay (Connect (Vertex 18) (Vertex 3)) (Connect (Vertex 19) (Vertex 3))))))))))))))))))))))))

** dotparse Graph

Convert to a dotparse Graph

#+begin_src haskell
exGraph = defaultGraph & addStatements (toStatements Directed (Char8.pack . show <$> exAGraph))
#+end_src

** dotPrint

Encode graph as a ByteString (prior to processing via graphviz)

#+begin_src haskell :results output :exports both
BS.putStr (dotPrint defaultDotConfig exGraph)
#+end_src

#+RESULTS:
#+begin_example
digraph {
    node [height=0.5;shape=circle]
    graph [overlap=false;size="1!";splines=spline]
    edge [arrowsize=0.5]
    "9"
    "8"
    "7"
    "6"
    "5"
    "4"
    "3"
    "2"
    "19"
    "18"
    "17"
    "16"
    "15"
    "14"
    "13"
    "12"
    "11"
    "10"
    "1"
    "0"
    "5" -> "17"
    "5" -> "11"
    "5" -> "0"
    "4" -> "5"
    "4" -> "16"
    "4" -> "10"
    "3" -> "9"
    "3" -> "4"
    "3" -> "15"
    "2" -> "8"
    "2" -> "3"
    "2" -> "19"
    "2" -> "18"
    "2" -> "14"
    "19" -> "3"
    "18" -> "3"
    "15" -> "19"
    "15" -> "18"
    "1" -> "7"
    "1" -> "2"
    "1" -> "13"
    "0" -> "6"
    "0" -> "12"
    "0" -> "1"
    }
#+end_example

** processDotWith

Directly create an SVG from the dotparse Graph

#+begin_src haskell :file other/exdirect.svg :results output graphics file :exports both
(\b f -> processDotWith Directed ["-Tsvg", "-o", "other/" <> f <> ".svg"] b) (dotPrint defaultDotConfig exGraph) "exdirect"
        #+end_src

#+RESULTS:
[[file:other/exdirect.svg]]

** processDot

ByteString of the processed Graph

#+begin_src haskell :results output
BS.putStr =<< processDot Directed (dotPrint defaultDotConfig exInt)
#+end_src

** processGraph

Graph augmented by graphviz

#+begin_src haskell
exGraphAugmented <- processGraph exGraph
:t exGraphAugmented
#+end_src

#+RESULTS:
: exGraphAugmented :: Graph

** graphToChartWith

SVG production via chart-svg

#+begin_src haskell :file other/exga.svg :results output graphics file :exports both
import Chart (writeChartOptions)
writeChartOptions "other/exga.svg" (graphToChart exGraphAugmented)
#+end_src

#+RESULTS:
[[file:other/exga.svg]]

* Development

** write examples

Round-trip test

#+begin_src haskell :results output
testAll
#+end_src

#+RESULTS:
#+begin_example
ex0
ex1
ex2
ex3
ex4
ex5
ex6
ex7
ex8
ex9
ex10
ex11
ex12
ex13
ex14
ex15
#+end_example

Render examples

#+begin_src haskell
svgAll
#+end_src

#+RESULTS:
#+begin_example
ex0
ex1
ex2
ex3
ex4
ex5
ex6
ex7
ex8
ex9
ex10
ex11
ex12
ex13
ex14
ex15
#+end_example

** numhask example

  #+begin_src haskell
writeNHChart
  #+end_src

This is bugged downstream as chart-svg uses the link string (which is very long compared with the displayed text) to estimate the bounding box and results in a very wide chart with a lot of white space either side.

** Base example

  #+begin_src haskell
writeEqChart
  #+end_src

#+RESULTS:

Manual dot process

#+begin_src haskell :results output
bs <- processDotWith Directed ["-Tsvg"] $ dotPrint defaultDotConfig (dotGraphEq Directed)
BS.writeFile "x.svg" bs
#+end_src

#+RESULTS:


#+begin_src sh :results output
dot -Tsvg other/raweq.dot -o other/raweq.svg
#+end_src

#+begin_quote
digraph {
    node [height=0.5;shape=box]
    graph [overlap=false;size=5;splines=spline]
    edge [arrowsize=1]
    rankdir="TB"
    "RealFrac"
    "RealFloat"
    "Real"
    "Ord2"
    "Ord1"
    "Ord"
    "Num"
    "Ix"
    "Integral"
    "Fractional"
    "Floating"
    "FiniteBits"
    "Eq2"
    "Eq1"
    "Eq"
    "Enum"
    "Bits"
    "RealFrac" -> "RealFloat"
    "Real" -> "RealFrac"
    "Real" -> "Integral"
    "Ord1" -> "Ord2"
    "Ord" -> "Real"
    "Ord" -> "Ord1"
    "Ord" -> "Ix"
    "Num" -> "Real"
    "Num" -> "Fractional"
    "Fractional" -> "Floating"
    "Floating" -> "RealFloat"
    "Eq1" -> "Eq2"
    "Eq" -> "Ord"
    "Eq" -> "Eq1"
    "Eq" -> "Bits"
    "Enum" -> "Integral"
    "Bits" -> "FiniteBits"
    }
#+end_quote

** reproduction of svg that dot creates

base graph

#+begin_src haskell :results output
baseGraph = defaultGraph & #directed .~ Data.Monoid.Last (Just Directed) & addStatements (toStatements Directed (FP.strToUtf8 . show <$> graphEqG)) & attL NodeType (ID "shape") .~ Just (ID "box") & gattL (ID "rankdir") .~ Just (IDQuoted "TB") & attL GraphType (ID "size") .~ Just (IDQuoted "5!")
#+end_src

#+RESULTS:

baseGraph dot

#+begin_src haskell :results output
BS.putStr $ dotPrint defaultDotConfig baseGraph
#+end_src

#+RESULTS:
#+begin_example
digraph {
    node [height=0.5;shape=box]
    graph [overlap=false;size="5!";splines=spline]
    edge [arrowsize=0.5]
    rankdir="TB"
    "RealFrac"
    "RealFloat"
    "Real"
    "Ord2"
    "Ord1"
    "Ord"
    "Num"
    "Ix"
    "Integral"
    "Fractional"
    "Floating"
    "FiniteBits"
    "Eq2"
    "Eq1"
    "Eq"
    "Enum"
    "Bits"
    "RealFrac" -
"RealFloat"
    "Real" -
"RealFrac"
    "Real" -
"Integral"
    "Ord1" -
"Ord2"
    "Ord" -
"Real"
    "Ord" -
"Ord1"
    "Ord" -
"Ix"
    "Num" -
"Real"
    "Num" -
"Fractional"
    "Fractional" -
"Floating"
    "Floating" -
"RealFloat"
    "Eq1" -
"Eq2"
    "Eq" -
"Ord"
    "Eq" -
"Eq1"
    "Eq" -
"Bits"
    "Enum" -
"Integral"
    "Bits" -
"FiniteBits"
    }
#+end_example

Processed dot SVG

file:///Users/tonyday/haskell/dotparse/other/repro.svg

#+begin_src haskell :file other/repro.svg :results output graphics file :exports both
import Data.Monoid
(\b f -> processDotWith Directed ["-Tsvg", "-o", "other/" <> f <> ".svg"] b) (dotPrint defaultDotConfig baseGraph) "repro"
        #+end_src

#+RESULTS:
[[file:other/repro.svg]]

Pre-scaled height was 332


Processed dot Dot

#+begin_src haskell :results output
bs <- processDot Directed (dotPrint defaultDotConfig baseGraph)
BS.putStr bs
#+end_src

#+RESULTS:
#+begin_example
digraph {
	graph [bb="0,0,525,324",
		overlap=false,
		rankdir=TB,
		size="5!",
		splines=spline
	];
	node [height=0.5,
		label="\N",
		shape=box
	];
	edge [arrowsize=0.5];
	RealFrac	[pos="113,90",
		width=0.90278];
	RealFloat	[pos="72,18",
		width=0.95833];
	RealFrac -
RealFloat	[pos="e,82.018,36.104 102.87,71.697 97.553,62.626 90.98,51.404 85.267,41.65"];
	Real	[pos="117,162",
		width=0.75];
	Real -
RealFrac	[pos="e,113.98,108.1 116.01,143.7 115.51,134.88 114.89,124.03 114.34,114.47"];
	Integral	[pos="193,90",
		width=0.81944];
	Real -
Integral	[pos="e,174.17,108.35 135.79,143.7 146.02,134.27 158.77,122.53 169.64,112.52"];
	Ord2	[pos="268,90",
		width=0.75];
	Ord1	[pos="266,162",
		width=0.75];
	Ord1 -
Ord2	[pos="e,267.51,108.1 266.49,143.7 266.75,134.88 267.06,124.03 267.33,114.47"];
	Ord	[pos="302,234",
		width=0.75];
	Ord -
Real	[pos="e,144.47,174.89 274.58,223.45 245.31,213.15 197.63,196.05 157,180 154.84,179.15 152.62,178.25 150.38,177.34"];
	Ord -
Ord1	[pos="e,274.8,180.1 293.1,215.7 288.44,206.63 282.67,195.4 277.65,185.65"];
	Ix	[pos="338,162",
		width=0.75];
	Ord -
Ix	[pos="e,329.2,180.1 310.9,215.7 315.56,206.63 321.33,195.4 326.35,185.65"];
	Num	[pos="77,234",
		width=0.75];
	Num -
Real	[pos="e,107.23,180.1 86.888,215.7 92.071,206.63 98.483,195.4 104.06,185.65"];
	Fractional	[pos="36,162",
		width=0.98611];
	Num -
Fractional	[pos="e,46.018,180.1 66.865,215.7 61.553,206.63 54.98,195.4 49.267,185.65"];
	Floating	[pos="31,90",
		width=0.86111];
	Fractional -
Floating	[pos="e,32.222,108.1 34.764,143.7 34.134,134.88 33.359,124.03 32.677,114.47"];
	Floating -
RealFloat	[pos="e,61.982,36.104 41.135,71.697 46.447,62.626 53.02,51.404 58.733,41.65"];
	FiniteBits	[pos="490,162",
		width=0.97222];
	Eq2	[pos="410,162",
		width=0.75];
	Eq1	[pos="410,234",
		width=0.75];
	Eq1 -
Eq2	[pos="e,410,180.1 410,215.7 410,206.88 410,196.03 410,186.47"];
	Eq	[pos="410,306",
		width=0.75];
	Eq -
Ord	[pos="e,328.63,252.26 383.03,287.52 368.09,277.84 349.45,265.75 333.81,255.62"];
	Eq -
Eq1	[pos="e,410,252.1 410,287.7 410,278.88 410,268.03 410,258.47"];
	Bits	[pos="486,234",
		width=0.75];
	Eq -
Bits	[pos="e,467.17,252.35 428.79,287.7 439.02,278.27 451.77,266.53 462.64,256.52"];
	Enum	[pos="193,162",
		width=0.75];
	Enum -
Integral	[pos="e,193,108.1 193,143.7 193,134.88 193,124.03 193,114.47"];
	Bits -
FiniteBits	[pos="e,489.02,180.1 486.99,215.7 487.49,206.88 488.11,196.03 488.66,186.47"];
}
#+end_example

#+begin_src haskell :results output
import Control.Monad
BS.putStr =<< (dotPrint defaultDotConfig <$> processGraph baseGraph)
#+end_src

#+RESULTS:
#+begin_example
digraph {
    node [height=0.5;label="\N";shape=box]
    graph [bb="0,0,525,324";overlap=false;rankdir=TB;size="5!";splines=spline]
    edge [arrowsize=0.5]
    Enum [pos="193,162";width=0.75]
    Bits [pos="486,234";width=0.75]
    Eq [pos="410,306";width=0.75]
    Eq1 [pos="410,234";width=0.75]
    Eq2 [pos="410,162";width=0.75]
    FiniteBits [pos="490,162";width=0.97222]
    Floating [pos="31,90";width=0.86111]
    Fractional [pos="36,162";width=0.98611]
    Num [pos="77,234";width=0.75]
    Ix [pos="338,162";width=0.75]
    Ord [pos="302,234";width=0.75]
    Ord1 [pos="266,162";width=0.75]
    Ord2 [pos="268,90";width=0.75]
    Integral [pos="193,90";width=0.81944]
    Real [pos="117,162";width=0.75]
    RealFloat [pos="72,18";width=0.95833]
    RealFrac [pos="113,90";width=0.90278]
    Bits -
FiniteBits [pos="e,489.02,180.1 486.99,215.7 487.49,206.88 488.11,196.03 488.66,186.47"]
    Enum -
Integral [pos="e,193,108.1 193,143.7 193,134.88 193,124.03 193,114.47"]
    Eq -
Bits [pos="e,467.17,252.35 428.79,287.7 439.02,278.27 451.77,266.53 462.64,256.52"]
    Eq -
Eq1 [pos="e,410,252.1 410,287.7 410,278.88 410,268.03 410,258.47"]
    Eq -
Ord [pos="e,328.63,252.26 383.03,287.52 368.09,277.84 349.45,265.75 333.81,255.62"]
    Eq1 -
Eq2 [pos="e,410,180.1 410,215.7 410,206.88 410,196.03 410,186.47"]
    Floating -
RealFloat [pos="e,61.982,36.104 41.135,71.697 46.447,62.626 53.02,51.404 58.733,41.65"]
    Fractional -
Floating [pos="e,32.222,108.1 34.764,143.7 34.134,134.88 33.359,124.03 32.677,114.47"]
    Num -
Fractional [pos="e,46.018,180.1 66.865,215.7 61.553,206.63 54.98,195.4 49.267,185.65"]
    Num -
Real [pos="e,107.23,180.1 86.888,215.7 92.071,206.63 98.483,195.4 104.06,185.65"]
    Ord -
Ix [pos="e,329.2,180.1 310.9,215.7 315.56,206.63 321.33,195.4 326.35,185.65"]
    Ord -
Ord1 [pos="e,274.8,180.1 293.1,215.7 288.44,206.63 282.67,195.4 277.65,185.65"]
    Ord -
Real [pos="e,144.47,174.89 274.58,223.45 245.31,213.15 197.63,196.05 157,180 154.84,179.15 152.62,178.25 150.38,177.34"]
    Ord1 -
Ord2 [pos="e,267.51,108.1 266.49,143.7 266.75,134.88 267.06,124.03 267.33,114.47"]
    Real -
Integral [pos="e,174.17,108.35 135.79,143.7 146.02,134.27 158.77,122.53 169.64,112.52"]
    Real -
RealFrac [pos="e,113.98,108.1 116.01,143.7 115.51,134.88 114.89,124.03 114.34,114.47"]
    RealFrac -
RealFloat [pos="e,82.018,36.104 102.87,71.697 97.553,62.626 90.98,51.404 85.267,41.65"]
    }
#+end_example

#+begin_src haskell :results output
:set -Wno-name-shadowing
g <- processGraph baseGraph
c = graphToChart g
cs = view #charts c
import Data.Tree
import Data.Bool

cs' = foldTree (\a xs -> bool [] (snd a <> mconcat xs) (fst a == (Just "labels"))) (tree cs)
csLabels = mconcat $ fmap snd <$> filter ((== Just "labels") . fst) $ flatten (tree cs)
csEdges = mconcat $ fmap snd <$> filter ((== Just "edges") . fst) $ flatten (tree cs)
csShapes = mconcat $ fmap snd <$> filter ((== Just "shapes") . fst) $ flatten (tree cs)
csLabels
#+end_src

#+RESULTS:
: [TextChart (TextStyle {size = 14.0, color = Colour -0.51 0.30 0.37 1.00, anchor = AnchorMiddle, hsize = 0.45, vsize = 1.1, vshift = -0.25, rotation = Nothing, scalex = ScaleX, escapeText = NoEscapeText, frame = Nothing}) [("Bits",Point 486.0 230.3),("Enum",Point 193.0 158.3),("Eq",Point 410.0 302.3),("Eq1",Point 410.0 230.3),("Eq2",Point 410.0 158.3),("FiniteBits",Point 490.0 158.3),("Floating",Point 31.0 86.3),("Fractional",Point 36.0 158.3),("Integral",Point 193.0 86.3),("Ix",Point 338.0 158.3),("Num",Point 77.0 230.3),("Ord",Point 302.0 230.3),("Ord1",Point 266.0 158.3),("Ord2",Point 268.0 86.3),("Real",Point 117.0 158.3),("RealFloat",Point 72.0 14.3),("RealFrac",Point 113.0 86.3)]]

#+begin_src haskell :results output
csShapes
#+end_src

#+RESULTS:
: [GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 486.0 234.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 193.0 162.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 410.0 306.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 410.0 234.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 410.0 162.0],GlyphChart (GlyphStyle {size = 69.99983999999999, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.5142868897986053, rotation = Nothing, translate = Nothing}) [Point 490.0 162.0],GlyphChart (GlyphStyle {size = 61.99992, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.5806459105108522, rotation = Nothing, translate = Nothing}) [Point 31.0 90.0],GlyphChart (GlyphStyle {size = 70.99992, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.5070428248369857, rotation = Nothing, translate = Nothing}) [Point 36.0 162.0],GlyphChart (GlyphStyle {size = 58.99968, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6101728009372255, rotation = Nothing, translate = Nothing}) [Point 193.0 90.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 338.0 162.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 77.0 234.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 302.0 234.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 266.0 162.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 268.0 90.0],GlyphChart (GlyphStyle {size = 54.0, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.6666666666666666, rotation = Nothing, translate = Nothing}) [Point 117.0 162.0],GlyphChart (GlyphStyle {size = 68.99976, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.5217409451858963, rotation = Nothing, translate = Nothing}) [Point 72.0 18.0],GlyphChart (GlyphStyle {size = 65.00016000000001, color = Colour 0.02 0.73 0.80 0.20, borderColor = Colour -0.51 0.30 0.37 1.00, borderSize = 1.0, shape = RectSharpGlyph 0.5538447905359002, rotation = Nothing, translate = Nothing}) [Point 113.0 90.0]]

#+begin_src haskell :results output
display c
#+end_src

#+RESULTS:
: True

* chart-svg AST

#+begin_src haskell-ng :results output
g1 = dotAST allSC componentEdges
-- g1' <- processGraph g1
BS.writeFile "other/ast.dot" $ dotPrint defaultDotConfig g1
#+end_src

#+RESULTS:

#+begin_src sh :results output
dot other/ast.dot -Tsvg >other/ast.svg
#+end_src


#+RESULTS:
